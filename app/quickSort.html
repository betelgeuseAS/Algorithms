<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <!-- <base href="/"> -->

  <title>Quick sort</title>
  <meta name="description" content="">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- Template Basic Images Start -->
  <meta property="og:image" content="path/to/image.jpg">
  <link rel="icon" href="img/favicon/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="img/favicon/apple-touch-icon-180x180.png">
  <!-- Template Basic Images End -->

  <!-- Custom Browsers Color Start -->
  <meta name="theme-color" content="#000">
  <!-- Custom Browsers Color End -->

  <link rel="stylesheet" href="css/main.min.css">
</head>
<body>

<header>
  <div class="container">
    <div class="row">
      <div class="col-8">
        <div class="name">
          <h1><a href="index.html"><i class="fa fa-sun-o" aria-hidden="true"></i> Algorithms</a></h1>
        </div>
      </div>
      <div class="col-4">
        <ul>
          <li><a target="_blank" href="https://github.com/betelgeuseAS/Algorithms">GitHub <i class="fa fa-link" aria-hidden="true"></i></a></li>
        </ul>
      </div>
    </div>
  </div>
</header>


<section>
  <div class="container">
    <div class="row">
      <div class="col-md-9 col-sm-12">
        <div class="leftSide">
          <h1>Быстрая сортировка</h1>
          <p></p>

          <hr>

          <h3>Разделяй и властвуй</h3>
          <p>Возможно, вы не сразу поймете суть стратегии «разделяй и властвуй~, поэтому мы рассмотрим три примера. Сначала я приведу наглядный пример. Потом мы разберем пример кода, который выглядит не так красиво, но, пожалуй, воспринимается проще. В завершение будет рассмотрена быстрая сортировка - алгоритм сортировки, использующий стратегию "разделяй и властвуй".</p>
          <p>Представьте, что вы фермер, владеющий земельным участком.</p>

          <img src="img/algorithms/Quick%20sort/qs01.jpg" class="img-responsive" alt="Quick sort">

          <p>Вы хотите равномерно разделить землю на одинаковые квадратные участки. Участки должны быть настолько большими, насколько это возможно, так что ни одно из следующих решений не подойдет.</p>

          <img src="img/algorithms/Quick%20sort/qs02.jpg" class="img-responsive" alt="Quick sort">

          <p>Как определить наибольший размер квадрата для участка? Воспользуйтесь стратегией "разделяй и властвуй"! Алгоритмы на базе этой стратегии являются рекурсивными.</p>
          <p>Решение задачи методом «разделяй и властвуй~ состоит из двух шагов:</p>
          <ol>
            <li>Сначала определяется базовый случай. Это должен быть простейший случай из всех возможных.</li>
            <li>Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.</li>
          </ol>
          <p>А теперь воспользуемся стратегией «разделяй и властвуй~ для поиска решения этой задачи.</p>
          <p>Для начала нужно определить базовый случай. Самая простая ситуация если длина одной стороны кратна длине другой стороны.</p>

          <img src="img/algorithms/Quick%20sort/qs03.jpg" class="img-responsive" alt="Quick sort">

          <p>Предположим, длина одной стороны составляет 25 м, а длина другой 50 м. В этом случае размер самого большого участка составляет 25 м х 25 м, и надел после деления будет состоять из двух участков.</p>
          <p>Теперь нужно вычислить рекурсивный случай. Здесь-то вам на помощь и приходит стратегия «разделяй и властвуй~. В соответствии с ней при каждом рекурсивном вызове задача должна сокращаться. Как сократить эту задачу? Для начала разметим самые большие участки, которые можно использовать.</p>

          <img src="img/algorithms/Quick%20sort/qs04.jpg" class="img-responsive" alt="Quick sort">

          <p>В исходном наделе можно разместить два участка 640 х 640, и еще останется место. Тут-то и наступает момент истины. Нераспределенный остаток - это тоже надел земли, который нужно разделить. Так почему бы не применить к нему тот же алгоритм?</p>

          <img src="img/algorithms/Quick%20sort/qs05.jpg" class="img-responsive" alt="Quick sort">

          <p>Итак, мы начали с надела 1680 х 640, который необходимо разделить на участки. Но теперь разделить нужно меньший сегмент - 640 х 400. Если вы найдете самый большой участок, подходящий для этого размера, это будет самый большой участок, подходящий для всей фермы. Мы только что сократили задачу с размера 1680 х 640 до 640 х 400!</p>

          <div class="tip tipWarning">
            <h4>Алгоритм Евклида</h4>
            <p>"Если вы найдете самый большой участок, подходящий для этого размера, это будет самый большой участок, подходящий для всей фермы." Если вас интересует доказательство, поищите "Алгоритм Евклида". Хорошое объяснение содержится на <a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm" target="_blank" class="link">сайте</a>.</p>
          </div>

          <img src="img/algorithms/Quick%20sort/qs06.jpg" class="img-responsive" alt="Quick sort">

          <p>Применим тот же алгоритм снова. Если начать с участка 640 х 400, то размеры самого большого квадрата, который можно создать, составляют 400 х 400 м.</p>
          <p>Остается меньший сегмент с размерами 400 х 240 м.</p>

          <img src="img/algorithms/Quick%20sort/qs07.jpg" class="img-responsive" alt="Quick sort">

          <p>Отсекая поделенную часть, мы приходим к еще меньшему размеру сегмента, 240 Х 160 м.</p>

          <img src="img/algorithms/Quick%20sort/qs08.jpg" class="img-responsive" alt="Quick sort">

          <p>После очередного отсечения получается еще меньший сегмент.</p>

          <img src="img/algorithms/Quick%20sort/qs09.jpg" class="img-responsive" alt="Quick sort">

          <p>Да мы пришли к базовому случаю: 160 кратно 80. Если разбить этот сегмент на квадраты, ничего лишнего не останется!</p>

          <img src="img/algorithms/Quick%20sort/qs10.jpg" class="img-responsive" alt="Quick sort">

          <p>Итак, для исходного надела земли самый большой размер участка будет равен 80 х 80 м.</p>

          <img src="img/algorithms/Quick%20sort/qs11.jpg" class="img-responsive" alt="Quick sort">

          <p>"Разделяй и властвуй" - не простой алгоритм, который можно применить для решения задачи. Скорее, это подход к решению задачи. Рассмотрим еще один пример.</p>
          <p>Имеется массив чисел.</p>

          <img src="img/algorithms/Quick%20sort/qs12.jpg" class="img-responsive" alt="Quick sort">

          <p>Нужно просуммировать все числа и вернуть сумму. Сделать это в цикле совсем не сложно:</p>

<pre data-src-loaded><code class="language-javascript">
  const sum = arr => {
    let total = 0;
    for (var i = 0; i < arr.length; i++) {
      total += arr[i];
    }
    return total;
  }
</code></pre>

          <p>Но как сделать то же самое с использованием рекурсивной функции?</p>
          <p><strong>Шаr 1</strong>: определить базовый случай. Как выглядит самый простой массив, который вы можете получить? Если у вас будет массив с О или 1 элементом, он суммируется достаточно просто.</p>

          <img src="img/algorithms/Quick%20sort/qs13.jpg" class="img-responsive" alt="Quick sort">

          <p>Итак, с базовым случаем мы определились.</p>
          <p><strong>Шаr 2</strong>: каждый рекурсивный вызов должен приближать вас к пустому массиву. Как уменьшить размер задачи? Один из возможных способов:</p>

          <img src="img/algorithms/Quick%20sort/qs14.jpg" class="img-responsive" alt="Quick sort">

          <p>В любом случае результат равен 12. Но во второй версии функции sum передается меньший массив. А это означает, что вы сократили размер своей задачи!</p>
          <p>Функция sum может работать по следующей схеме:</p>

          <img src="img/algorithms/Quick%20sort/qs15.jpg" class="img-responsive" alt="Quick sort">

          <p>А вот как это выглядит в действии.</p>

          <img src="img/algorithms/Quick%20sort/qs16.jpg" class="img-responsive" alt="Quick sort">

          <p>Вспомните, что при рекурсии сохраняется состояние.</p>

          <img src="img/algorithms/Quick%20sort/qs17.jpg" class="img-responsive" alt="Quick sort">

          <div class="tip tipSuccess">
            <h4>Совет</h4>
            <p>Когда вы пишите рекурсивную функцию, в которой задействован массив, базовым случаем часто оказывается пустой массив или массив из одного элемента. Если вы не знаете, с чего начать, - начните с этого.</p>
          </div>

          <hr>

          <h3>Быстрая сортировка</h3>
          <p>Быстрая сортировка относится к алгоритмам сортировки. Она работает намного быстрее сортировки выбором и часто применяется в реальных программах. Например, в стандартную библиотеку С входит функция с именем qsort, реализующая быструю сортировку. Быстрая сортировка также основана на стратегии "разделяй и властвуй".</p>
          <p>Воспользуемся быстрой сортировкой для упорядочения массива. Как выглядит самый простой массив, с которым может справиться алгоритм сортировки? Некоторые массивы вообще не нуждаются в сортировке.</p>

          <img src="img/algorithms/Quick%20sort/qs18.jpg" class="img-responsive" alt="Quick sort">

          <p>Пустые массивы и массивы, содержащие всего один элемент, станут базовым случаем. Такие массивы можно просто возвращать в исходном виде сортировать ничего не нужно:</p>

<pre data-src-loaded><code class="language-javascript">
  const quickSort = array => {
    if (array.length < 2) {
      return array;
    }
  }
</code></pre>

          <p>Теперь перейдем к массивам большего размера. Массив из двух элементов тоже сортируется без особых проблем.</p>

          <img src="img/algorithms/Quick%20sort/qs19.jpg" class="img-responsive" alt="Quick sort">

          <p>А как насчет массива из трех элементов?</p>

          <img src="img/algorithms/Quick%20sort/qs20.jpg" class="img-responsive" alt="Quick sort">

          <p>Помните: мы используем стратегию "разделяй и властвуй". Следовательно, массив должен разделяться до тех пор, пока мы не придем к базовому случаю. Алгоритм быстрой сортировки работает так: сначала в массиве выбирается элемент, который называется <em>опорным</em>.</p>

          <img src="img/algorithms/Quick%20sort/qs21.jpg" class="img-responsive" alt="Quick sort">

          <p>О том, как выбрать хороший опорный элемент, будет рассказано далее. А пока предположим, что опорным становится первый элемент массива.</p>
          <p>Теперь мы находим элементы, меньшие опорного, и элементы, большие опорного.</p>

          <img src="img/algorithms/Quick%20sort/qs22.jpg" class="img-responsive" alt="Quick sort">

          <p>Этот процесс называется <em>разделением</em>. Теперь у вас имеются:</p>
          <ul>
            <li>подмассив всех элементов, меньших опорного;</li>
            <li>опорный элемент;</li>
            <li>подмассив всех элементов, больших опорного.</li>
          </ul>
          <p>Два подмассива не отсортированы - они просто выделены из исходного массива. Но если бы они бъuiu отсортированы, то провести сортировку всего массива было бы несложно.</p>

          <img src="img/algorithms/Quick%20sort/qs23.jpg" class="img-responsive" alt="Quick sort">

          <p>Если бы подмассивы были отсортированы, то их можно было бы объединить в порядке ~левый подмассив - опорный элемент - правый подмассив» и получить отсортированный массив. В нашем примере получается [10, 15] + [33] + [] = [10, 15, 33], то есть отсортированный массив.</p>
          <p>Как отсортировать подмассивы? Базовый случай быстрой сортировки уже знает, как сортировать массивы из двух элементов (левый подмассив) и пустые массивы (правый подмассив). Следовательно, если применить алгоритм быстрой сортировки к двум подмассивам, а затем объединить результаты, получится отсортированный массив!</p>
          <p>Этот метод работает при любом опорном элементе. Допустим, вместо 33 в качестве опорного был выбран элемент 15.</p>

          <img src="img/algorithms/Quick%20sort/qs24.jpg" class="img-responsive" alt="Quick sort">

          <p>Оба подмассива состоят из одного элемента, а вы уже умеете сортировать такие подмассивы. Получается, что вы умеете сортировать массивы из трех элементов. Это делается так:</p>
          <ol>
            <li>Выбрать опорный элемент.</li>
            <li>Разделить массив на два подмассива: элементы, меньшие опорного, и элементы, большие опорного.</li>
            <li>Рекурсивно применить быструю сортировку к двум подмассивам.</li>
          </ol>
          <p>Как насчет массива из четырех элементов?</p>

          <img src="img/algorithms/Quick%20sort/qs25.jpg" class="img-responsive" alt="Quick sort">

          <p>Предположим, опорным снова выбирается элемент 33.</p>

          <img src="img/algorithms/Quick%20sort/qs26.jpg" class="img-responsive" alt="Quick sort">

          <p>Левый подмассив состоит из трех элементов. Вы уже знаете, как сортируется массив из трех элементов: нужно рекурсивно применить к нему быструю сортировку.</p>

          <img src="img/algorithms/Quick%20sort/qs27.jpg" class="img-responsive" alt="Quick sort">

          <p>Следовательно, вы можете отсортировать массив из четырех элементов. А если вы можете отсортировать массив из четырех элементов, то вы также можете отсортировать массив из пяти элементов. Почему? Допустим, имеется массив из пяти элементов.</p>

          <img src="img/algorithms/Quick%20sort/qs28.jpg" class="img-responsive" alt="Quick sort">

          <p>Вот как выглядят все варианты разделения этого массива в зависимости от выбранного опорного элемента:</p>

          <img src="img/algorithms/Quick%20sort/qs29.jpg" class="img-responsive" alt="Quick sort">

          <p>Все эти подмассивы содержат от О до 4 элементов. А вы уже знаете, как отсортировать массив, содержащий от О до 4 элементов, с использованием быстрой сортировки! Таким образом, независимо от выбора опорного элемента вы можете рекурсивно вызывать быструю сортировку для двух подмассивов.</p>
          <p>Например, предположим, что в качестве опорного выбирается элемент 3. Вы применяете быструю сортировку к подмассивам.</p>

          <img src="img/algorithms/Quick%20sort/qs30.jpg" class="img-responsive" alt="Quick sort">

          <p>Подмассивы отсортированы, и теперь из них можно собрать отсортированный массив. Решение работает даже в том случае, если выбрать в качестве опорного элемент 5:</p>

          <img src="img/algorithms/Quick%20sort/qs31.jpg" class="img-responsive" alt="Quick sort">

          <p>Итак, решение работает независимо от выбора опорного элемента. Следовательно, вы можете отсортировать массив из пяти элементов. По той же логике вы можете отсортировать массив из шести элементов и т.д.</p>

          <div class="tip tipWarning">
            <h4>Доказательство по индукции</h4>
            <p>Вы только что познакомились с методом доказательства по индукции! Это один из способов, доказывающих, что ваш алгоритм работает. Каждое индуктивное доказательство состоит из двух частей: базы (базового случая) и индукционного перехода. Допустим, я хочу доказать, что могу подняться на самый верх стремянки. Если мои ноги стоят на ступеньке, то я могу переставить их на следующую ступеньку, - это индукционный переход. Таким образом, если я стою на ступеньке 2, то могу поднятся на ступеньку 3. Что касается базового случая, я сейчас стою на ступеньке 1. Из этого следует, что я могу подняться на самый верх стремянки, каждый раз поднимаясь на одну ступеньку.</p>
            <p>Аналогичные рассуждения применимы к быстрой сортировке. Работоспособность алгоритма для базового случая - массивов с размером 0 и 1 - была продемонстрирована. В индукционном переходе было показано, что если быстрая сортировка работает для массива из 1 елемента, то она будет работать для массива из 2 элементов. А если она работает для массивов из 2 елементов, то она будет работать для массивов из 3 елементов и т.д. Из этого можно сделать вывод, что быстрая сортировка  будет работать для всех массивов любого размера.</p>
          </div>

          <p>А вот как выглядит программный код быстрой сортировки:</p>

<pre data-src-loaded><code class="language-javascript">
  const quicksort = array => {
    if (array.length <= 1) {
      return array;
    }

    let pivot = array[0]; //Рекурсивный случай

    let left = []; //Подмассив всех элементов, меньших опорного
    let right = []; //Подмассив всех элементов, больших опорного

    for (let i = 1; i < array.length; i++) {
      array[i] < pivot ? left.push(array[i]) : right.push(array[i]);
    }

    return quicksort(left).concat(pivot, quicksort(right)); //left + pivot + right
  };
</code></pre>

          <hr>

          <h3>Снова об «О-большом»</h3>
          <p>Алгоритм быстрой сортировки уникален тем, что его скорость зависит от выбора опорного элемента.</p>
          <p>Возьмем алгоритм сортировки выбором. Он обладает временем О(n<sup>2</sup>), и это довольно медленный алгоритм. Другой алгоритм сортировки - так называемая сортировка слиянием работает за время О(n log n). Намного быстрее! С быстрой сортировкой дело обстоит сложнее. В худшем случае быстрая сортировка работает за время О(n<sup>2</sup>).</p>
          <p>Ничуть не лучше сортировки выбором! Но это худший случай, а в среднем быстрая сортировка выполняется за время О(n log n). Вероятно, вы спросите:</p>
          <ul>
            <li>что в данном случае понимается под <em>"худшим"</em> и <em>"средним"</em> случаем?</li>
            <li>если быстрая сортировка в среднем выполняется за время О(n log n), а сортировка слиянием выполняется за время О(n log n) всегда, то почему бы не использовать сортировку слиянием? Разве она не быстрее?</li>
          </ul>

          <hr>

          <h3>Сортировка слиянием и быстрая сортировка</h3>
          <p>Допустим, у вас имеется простая функция для вывода каждого элемента в списке:</p>

<pre data-src-loaded><code class="language-javascript">
  const printItems = list => {
    for(let i = 0; i < list.length; i++) {
      console.log(list[i]);
    }
  };
</code></pre>

          <p>Эта функция последовательно перебирает все элементы списка и выводит их. Так как функция перебирает весь список, она выполняется за время О(n). Теперь предположим, что вы изменили эту функцию и она делает секундную паузу перед выводом:</p>

<pre data-src-loaded><code class="language-javascript">
  const printItems = list => {
    for(let i = 0; i < list.length; i++) {
      var timerId = setTimeout(() => {
        console.log(list[i]);
      }, 1000 * i);
    }
  };
</code></pre>

          <p>Перед вьводом элемента функция делает паузу продолжительностью в 1 секунду. Предположим, вы выводите список из пяти элементов с использованием обеих функций:</p>

          <img src="img/algorithms/Quick%20sort/qs32.jpg" class="img-responsive" alt="Quick sort">

          <p>Обе функции проходят по списку один раз, и обе выполняются за время О(n). Как вы думаете, какая из них работает быстрее? Я думаю, print_items работает намного быстрее, потому что она не делает паузу перед выводом каждого элемента. Следовательно, даже при том, что обе функции имеют одинаковую скорость "О-большое", реально print_items работает быстрее. Когда вы используете "О-большое" (например, О(n)), в действи тельности это означает следующее:</p>

          <img src="img/algorithms/Quick%20sort/qs33.jpg" class="img-responsive" alt="Quick sort">

          <p>Здесь с - некоторый фиксированный промежуток времени для вашего алгоритма. Он называется <em>константой</em>. Например, время выполнения может составлять 10 мисекунд * n для print_items против 1 секунды * n для print_items2.</p>
          <p>Обычно константа игнорируется, потому что если два алгоритма имеют разное время «О-большое~, она роли не играет. Для примера возьмем бинарный и простой поиск. Допустим, такие константы присутствуют в обоих алгоритмах.</p>

          <img src="img/algorithms/Quick%20sort/qs34.jpg" class="img-responsive" alt="Quick sort">

          <p>Первая реакция: "Ого! У простого поиска константа равна 10 миллисекундам, а у бинарного поиска - 1 секунда. Простой поиск намного быстрее!" Теперь предположим, что поиск ведется по списку из 4 миллиардов элементов. Время будет таким:</p>

          <img src="img/algorithms/Quick%20sort/qs35.jpg" class="img-responsive" alt="Quick sort">

          <p>Как видите, бинарный поиск все равно работает намного быстрее. Константа ни на что не повлияла.</p>
          <p>Однако в некоторых случаях константа может иметь значение. Один из примеров такого рода - быстрая сортировка и сортировка слиянием. У быстрой сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то Что оба алгоритма характеризуются временем О(п log п), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего.</p>
          <p>А теперь ответим на первый вопрос: как выглядит средний случай по сравнению с худшим?</p>

          <hr>

          <h3>Средний и худший случай</h3>
          <p>Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента. Предположим, опорным всегда выбирается первый элемент, а быстрая сортировка применяется к <em>уже отсортированному</em> массиву. Быстрая сортировка не проверяет, отсортирован входной массив или нет, и все равно пытается его отсортировать.</p>

          <img src="img/algorithms/Quick%20sort/qs36.jpg" class="img-responsive" alt="Quick sort">

          <p>Обратите внимание: на этот раз массив не разделяется на две половины. Вместо этого один из двух подмассивов всегда пуст, так что стек вызовов получается очень длинным. Теперь предположим, что в качестве опорного всегда выбирается средний элемент. Посмотрим, как выглядит стек вызовов в этом случае.</p>

          <img src="img/algorithms/Quick%20sort/qs37.jpg" class="img-responsive" alt="Quick sort">

          <p>Стек намного короче! Массив каждый раз делится надвое, поэтому такое количество рекурсивных вызовов излишне. Вы быстрее добираетесь до базового случая, и стек вызовов получается более коротким.</p>
          <p>Первый из рассмотренных примеров описывает худший сценарий, а второй - лучший. В худшем случае размер стека описывается как О(n). В лучшем случае он составит O(log n).</p>
          <p>Теперь рассмотрим первый уровень стека. Один элемент выбирается опорным, а остальные элементы делятся на подмассивы. Вы перебираете все восемь элементов массива, поэтому первая операция выполняется за время О(п). На этом уровне стека вызовов вы обратились ко всем восьми элементам. Но на самом деле вы обращаетесь к О(п) элементам на каждом уровне стека вызовов!</p>

          <img src="img/algorithms/Quick%20sort/qs38.jpg" class="img-responsive" alt="Quick sort">

          <p>Даже если массив будет разделен другим способом, вы все равно каждый раз обращаетесь к О(n) элементам.</p>

          <img src="img/algorithms/Quick%20sort/qs39.jpg" class="img-responsive" alt="Quick sort">

          <p>Итак, завершение каждого уровня требует времени О(n).</p>

          <img src="img/algorithms/Quick%20sort/qs40.jpg" class="img-responsive" alt="Quick sort">

          <p>В этом примере существуют O(log n) (с технической точки зрения правильнее сказать «высота стека вызовов равна O(log n)») уровней. А так как каждый уровень занимает время О(n), то весь алгоритм займет время О(n) * O(log n) = О(n log n). Это сценарий лучшего случая.</p>
          <p>В худшем случае существуют О(n) уровней, поэтому алгоритм займет время О(n) * О(n) = О(n<sup>2</sup>).</p>
          <p>А теперь сюрприз: лучший случай также является средним. Если вы всегда будете выбирать опорным элементом случайный элемент в массиве, быстрая сортировка в среднем завершится за время О(п log п). Это один из самых быстрых существующих алгоритмов сортировки, который заодно является хорошим примером стратегии «разделяй и властвуй».</p>





        </div>
      </div>

      <div class="col-md-3 col-sm-12">
        <div class="rightSide">
          <ul>
            <li class="active"><a href="quickSort.html">Быстрая сортировка</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</section>


<footer>
  <div class="container">
    <div class="row">
      <div class="col-12">
        <p>На основе книги <a class="link" target="_blank" href="https://www.manning.com/books/grokking-algorithms">Grokking Algorithms</a> - Aditya Y. Bhargava</p>
      </div>
    </div>
  </div>
</footer>


<!--Hamburger menu:-->
<div class="hamburger">
  <div class="buttonContainer">
    <span class="top"></span>
    <span class="middle"></span>
    <span class="bottom"></span>
  </div>
</div>


<script src="js/algorithms/quickSort.js"></script>
<script src="js/scripts.min.js"></script>
</body>
</html>
