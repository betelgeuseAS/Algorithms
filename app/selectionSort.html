<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <!-- <base href="/"> -->

  <title>Сортировка выбором</title>
  <meta name="description" content="">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- Template Basic Images Start -->
  <meta property="og:image" content="path/to/image.jpg">
  <link rel="icon" href="img/favicon/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="img/favicon/apple-touch-icon-180x180.png">
  <!-- Template Basic Images End -->

  <!-- Custom Browsers Color Start -->
  <meta name="theme-color" content="#000">
  <!-- Custom Browsers Color End -->

  <link rel="stylesheet" href="css/main.min.css">
</head>
<body>

<header>
  <div class="container">
    <div class="row">
      <div class="col-8">
        <div class="name">
          <h1><a href="index.html"><i class="fa fa-sun-o" aria-hidden="true"></i> Algorithms</a></h1>
        </div>
      </div>
      <div class="col-4">
        <ul>
          <li><a target="_blank" href="https://github.com/betelgeuseAS/Algorithms">GitHub <i class="fa fa-link" aria-hidden="true"></i></a></li>
        </ul>
      </div>
    </div>
  </div>
</header>


<section>
  <div class="container">
    <div class="row">
      <div class="col-md-9 col-sm-12">
        <div class="leftSide">
          <h1>Сортировка выбором</h1>

          <hr>

          <h3>Как работает память</h3>
          <p>Представьте, что вы пришли в театр и хотите оставить свои личные вещи в гардеробе. Для хранения вещей есть специальные ящики.</p>

          <img src="img/algorithms/Selection%20Sort/ss01.jpg" class="img-responsive" alt="Selection sort">

          <p>В каждом ящике помещается один предмет. Вы хотите сдать на хранение две вещи, поэтому требуете выделить вам два ящика.</p>

          <img src="img/algorithms/Selection%20Sort/ss02.jpg" class="img-responsive" alt="Selection sort">

          <p>И вы оставляете свои две вещи.</p>

          <img src="img/algorithms/Selection%20Sort/ss03.jpg" class="img-responsive" alt="Selection sort">

          <p>Готово, можно идти на спектакль!</p>
          <p>В сущности, именно так работает память вашего компьютера. Она представляет собой нечто вроде огромного шкафа с множеством ящиков, и у каждого ящика есть адрес.</p>

          <img src="img/algorithms/Selection%20Sort/ss04.jpg" class="img-responsive" alt="Selection sort">

          <p>feOffeeb - адрес ячейки памяти.</p>
          <p>Каждый раз, когда вы хотите сохранить в памяти отдельное значение, вы запрашиваете у компьютера место в памяти, а он выдает адрес для сохранения значения. Если же вам понадобится сохранить несколько элементов, это можно сделать двумя основными способами: воспользоваться массивом или списком. Далее мы обсудим массивы и списки, их достоинства и недостатки. Не существует единственно верного способа сохранения данных на все случаи жизни, поэтому вы должны знать, чем различаются разные способы.</p>

          <hr>

          <h3>Массивы и связанные списки</h3>
          <p>Иногда в памяти требуется сохранить список элементов. Предположим, вы пишете приложение для управления текущими делами. Описания задач должны храниться в виде списка в памяти.</p>
          <p>Что использовать - массив или связанный список? Для начала попробуем сохранить задачи в массиве, потому что этот способ более понятен. При использовании массива все задачи хранятся в памяти непрерывно (то есть рядом друг с другом).</p>

          <img src="img/algorithms/Selection%20Sort/ss05.jpg" class="img-responsive" alt="Selection sort">

          <p>Теперь предположим, что вы захотели добавить четвертую задачу. Но следующий ящик уже занят - там лежат чужие вещи!</p>

          <img src="img/algorithms/Selection%20Sort/ss06.jpg" class="img-responsive" alt="Selection sort">

          <p>Представьте, что вы пошли в кино с друзьями и нашли места для своей компании, но тут приходит еще один друг, и ему сесть уже некуда. Приходится искать новое место, где смогут разместиться все. В этом случае вам придется запросить у компьютера другой блок памяти, в котором поместятся все четыре задачи, а потом переместить все свои задачи туда.</p>
          <p>Если вдруг придет еще один друг, места опять не хватит, и вам всем придется перемещаться снова! Сплошная суета. Кроме того, добавление новых элементов в массив станет серьезной проблемой. Если свободного места нет и вам каждый раз приходится перемещаться в новую область в памяти, операция добавления нового элемента будет выполняться очень медленно. Простейшее решение - «бронирование мест»: даже если список состоит всего из 3 задач, вы запрашиваете у компьютера место на 10 позиций... просто на всякий случай. Тогда в список можно будет добавить до 10 задач, и ничего перемещать не придется. Это неплохое обходное решение, но у него есть пара недостатков:</p>
          <ul>
            <li>Лишнее место может не понадобиться, и тогда память будет расходоваться неэффективно. Вы ее не используете, однако никто другой ее использовать тоже не может.</li>
            <li>Если в список будет добавлено более 10 задач, перемещаться все равно придется.</li>
          </ul>
          <p>В общем, прием неплохой, но его нельзя назвать идеальным. Связанные списки решают проблему добавления новых элементов.</p>

          <hr>

          <h3>Связанные списки</h3>
          <p>При использовании связанного списка элементы могут размещаться где угодно в памяти.</p>

          <img src="img/algorithms/Selection%20Sort/ss07.jpg" class="img-responsive" alt="Selection sort">

          <p>В каждом элементе хранится адрес следующего элемента списка. Таким образом, набор произвольных адресов памяти объединяется в цепочку.</p>

          <img src="img/algorithms/Selection%20Sort/ss08.jpg" class="img-responsive" alt="Selection sort">

          <p>Все как в игре «Найди клад». Вы приходите по первому адресу, там написано: «Следующий элемент находится по адресу 123». Вы идете по адресу 123, там написано: «Следующий элемент находится по адресу 847» и т. д. Добавить новый элемент в связанный список проще простого: просто разместите его по любому адресу памяти и сохраните этот адрес в предыдущем элементе.</p>
          <p>Со связанными списками ничего перемещать в памяти не нужно. Также сама собой решается другая проблема: допустим, вы пришли в кино спятью друзьями. Вы пытаетесь найти место на шестерых, но кинотеатр уже забит, и найти шесть соседних мест невозможно. Нечто похожее происходит и с массивами. Допустим, вы пытаетесь найти для массива блок на 1 О ООО элементов. В памяти можно найти место для 1 О ООО элементов, но только не смежное. Для массива не хватает места! При хранении данных в связанном списке вы фактически говорите: «Ладно, тогда садимся на свободные места и смотрим кино». Если необходимое место есть в памяти, вы сможете сохранить данные в связанном списке.</p>

          <hr>

          <h3>Массивы</h3>
          <p>На сайтах со всевозможными хит-парадами и «первыми десятками» применяется жульническая тактика для увеличения количества просмотров. Вместо того чтобы вывести весь список на одной странице, они размещают по одному элементу на странице и заставляют вас нажимать кнопку Next для перехода к следующему элементу. Например, «десятка лучших злодеев в сериалах» не выводится на одной странице. Вместо этого вы начинаете с №10 и нажимаете Next на каждой странице, пока не доберетесь до №1. В результате сайту удается показать вам рекламу на целых 1О страницах, но нажимать Next 9 раз для перехода к первому месту скучно. Было бы гораздо лучше, если бы весь список помещался на одной странице, а вы бы могли просто щелкнуть на имени человека для получения дополнительной информации.</p>
          <p>Похожая проблема существует и у связанных списков. Допустим, вы хотите получить последний элемент связанного списка. Просто прочитать нужное значение не удастся, потому что вы не знаете, по какому адресу оно хранится. Вместо этого придется сначала обратиться к элементу №1 и узнать адрес элемента № 2, потом обратиться к элементу № 2 и узнать адрес элемента № 3". и так далее, пока не доберетесь до последнего элемента. Связанные списки отлично подходят в тех ситуациях, когда данные должны  читаться последовательно: сначала вы читаете один элемент, по адресу переходите к следующему элементу и т.д. Но если вы намерены прыгать по списку туда-сюда, держитесь подальше от связанных списков.</p>
          <p>С массивами дело обстоит совершенно иначе. Работая с массивом, вы заранее знаете адрес каждого его элемента. Допустим, массив содержит пять элементов и вы знаете, что он начинается с адреса 00. По какому адресу хранится пятый элемент?</p>

          <img src="img/algorithms/Selection%20Sort/ss09.jpg" class="img-responsive" alt="Selection sort">

          <p>Простейшая математика дает ответ: это адрес 04. Массивы прекрасно подходят для чтения элементов в произвольных позициях, потому что обращение к любому элементу в массиве происходит мгновенно. В связанном списке элементы не хранятся рядом друг с другом, поэтому мгновенно определить позицию i-го элемента в памяти невозможно - нужно обратиться к первому элементу, чтобы получить адрес второго элемента, затем обратиться ко второму элементу для получения адреса третьего - и так далее, пока вы не доберетесь до i-го.</p>

          <hr>

          <p>Ниже приведены примеры времени выполнения основных операций с массивами и списками.</p>

          <img src="img/algorithms/Selection%20Sort/ss10.jpg" class="img-responsive" alt="Selection sort">

          <hr>

          <h3>Вставка в середину списка</h3>
          <p>Предположим, вы решили, что список задач должен больше напоминать календарь. Прежде данные добавлялись только в конец списка, а теперь они должны добавляться в порядке их выполнения.</p>

          <img src="img/algorithms/Selection%20Sort/ss11.jpg" class="img-responsive" alt="Selection sort">

          <p>Что лучше подойдет для вставки элементов в середину: массивы или списки? Со списком задача решается изменением указателя в предыдущем элементе.</p>

          <img src="img/algorithms/Selection%20Sort/ss12.jpg" class="img-responsive" alt="Selection sort">

          <p>А при работе с массивом придется сдвигать вниз все остальные элементы.</p>

          <img src="img/algorithms/Selection%20Sort/ss13.jpg" class="img-responsive" alt="Selection sort">

          <p>А если свободного места не осталось, все данные придется скопировать в новую область памяти! В общем, списки лучше подходят для вставки элементов в середину.</p>

          <hr>

          <h3>Удаление</h3>
          <p>Что, если вы захотите удалить элемент? И снова список лучше подходит для этой операции, потому что в нем достаточно изменить указатель в предыдущем элементе. В массиве при удалении элемента все последующие элементы нужно будет сдвинуть вверх.</p>
          <p>В отличие от вставки удаление возможно всегда. Попытка вставки может быть неудачной, если в памяти не осталось свободного места. С удалением подобных проблем не бывает.</p>
          <p>Ниже приведены примеры времени выполнения основных операций с массивами и связанными списками.</p>

          <img src="img/algorithms/Selection%20Sort/ss14.jpg" class="img-responsive" alt="Selection sort">

          <p>Заметим, что вставка и удаление выполняются за время 0(1) только в том случае, если вы можете мгновенно получить доступ к удаляемому элементу. На практике обычно сохраняются ссылки на первый и последний элементы связанного списка, поэтому время удаления этих элементов составит всего 0(1).</p>
          <p>Какая структура данных используется чаще: массивы или списки? Очевидно, это зависит от конкретного сценария использования. Массивы чрезвычайно популярны из-за того, что они поддерживают произвольный доступ. Всего существуют два вида доступа: <em>произвольный</em> и <em>последовательный</em>. При последовательном доступе элементы читаются по одному, начиная с первого. Связанные списки поддерживают только последовательный доступ. Если вы захотите прочитать 10-й элемент связанного списка, вам придется прочитать первые 9 элементов и перейти по ссылкам к 10-му элементу. Я часто говорю, что массивы обладают более высокой скоростью чтения; это объясняется тем, что они поддерживают произвольный доступ. Многие реальные ситуации требуют произвольного доступа, поэтому массивы часто применяются на практике. Также массивы и списки используются для реализации других структур данных.</p>

          <hr>

          <h3>Сортировка выбором</h3>
          <p> Чтобы освоить этот алгоритм, вы должны понимать, как работают массивы и списки и О-большое. Допустим, у вас на компьютере записана музыка и для каждого исполнителя хранится счетчик воспроизведений.</p>

          <img src="img/algorithms/Selection%20Sort/ss15.jpg" class="img-responsive" alt="Selection sort">

          <p>Вы хотите отсортировать список по убыванию счетчика воспроизведений, чтобы самые любимые исполнители стояли на первых местах. Как это сделать?</p>
          <p>Одно из возможных решений - пройти по списку и найти исполнителя с наибольшим количеством воспроизведений. Этот исполнитель добавляется в новый список.</p>

          <img src="img/algorithms/Selection%20Sort/ss16.jpg" class="img-responsive" alt="Selection sort">

          <p>Потом то же самое происходит со следующим по количеству воспроизведений исполнителем.</p>

          <img src="img/algorithms/Selection%20Sort/ss17.jpg" class="img-responsive" alt="Selection sort">

          <p>Продолжая действовать так, мы получаем отсортированный список.</p>

          <img src="img/algorithms/Selection%20Sort/ss18.jpg" class="img-responsive" alt="Selection sort">

          <p>А теперь попробуем оценить происходящее с точки зрения теории вычислений и посмотрим, сколько времени будут занимать операции. Напомним, что время О(n) означает, что вы по одному разу обращаетесь к каждому элементу списка. Например, при простом поиске по списку исполнителей каждый исполнитель будет проверен один раз.</p>

          <img src="img/algorithms/Selection%20Sort/ss19.jpg" class="img-responsive" alt="Selection sort">

          <p>Чтобы найти исполнителя с наибольшим значением счетчика воспроизведения, необходимо проверить каждый элемент в списке. Как вы уже видели, это делается за время О(n). Итак, имеется операция, выполняемая за время О(n), и ее необходимо выполнить n раз:</p>

          <img src="img/algorithms/Selection%20Sort/ss20.jpg" class="img-responsive" alt="Selection sort">

          <div class="tip tipWarning">
            <h4>Уменшение количества проверяемых элементов</h4>
            <p>Возникает закономерный вопрос: при каждом выполнении операций количество элементов, которое нужно проверить, сокращается. Со временем все сведется к проверке всего одного элемента. Почему же время выполнения все равно оценивается как O(n<sup>2</sup>)? Это хороший вопрос, и ответ на него связан с ролью констант в О-большом. Вы правы, вам действительно не нужно каждый раз проверять весь список из n элементов. Сначала проверяюся n элементов, потом n - 1, n - 2 ... 2, 1. В среднем проверяется список из 1/2 x n элементов. Его время выполнения составит O(n x 1/2 x n). Однако константы (такие как 1/2) в О-большом игнорируются, поэтому мы просто используем O(n x n), или O(n<sup>2</sup>).</p>
          </div>

          <p>Все это требует времени О(n х n), или О(n<sup>2</sup>).</p>
          <p>Алгоритмы сортировки очень полезны. Например, теперь вы можете отсортировать:</p>
          <ul>
            <li>имена в телефонной книге;</li>
            <li>даты путешествий;</li>
            <li>сообщения электронной почты (от новых к старым).</li>
          </ul>
          <p>Алгоритм сортировки выбором легко объясняется, но медленно работает.</p>

          <hr>

          <h3>Реализация</h3>
          <p>Видео которое показывает работу сортировки вставками:</p>

          <video width="320" height="auto" controls="controls" poster="img/algorithms/Selection%20Sort/ssvideo01poster.png">
            <source src="img/algorithms/Selection%20Sort/ssvideo01.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
            Тег video не поддерживается вашим браузером.
          </video>

          <p>А вот код на JavaScript:</p>

<pre data-src-loaded><code class="language-javascript">
  const selectionSort = array => {
    let tmp;

    for (let i = 0; i < array.length; i++) {
      let indexMin = i; //установика min для текущей итерации i
      for (let j = i + 1; j < array.length; j++) {
        if (array[indexMin] > array[j]) {
          indexMin = j;
        }
      }

      // if (indexMin !== i) {
      //   [array[i], array[indexMin]] = [array[indexMin], array[i]];
      // }
      // or:
      tmp = array[i];
      array[i] = array[indexMin];
      array[indexMin] = tmp;
    }
    return array;
  };
</code></pre>

        </div>
      </div>

      <div class="col-md-3 col-sm-12">
        <div class="rightSide">
          <ul>
            <li class="active"><a href="selectionSort.html">Сортировка выбором</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</section>


<footer>
  <div class="container">
    <div class="row">
      <div class="col-12">
        <p>На основе книги <a class="link" target="_blank" href="https://www.manning.com/books/grokking-algorithms">Grokking Algorithms</a> - Aditya Y. Bhargava</p>
      </div>
    </div>
  </div>
</footer>


<!--Hamburger menu:-->
<div class="hamburger">
  <div class="buttonContainer">
    <span class="top"></span>
    <span class="middle"></span>
    <span class="bottom"></span>
  </div>
</div>


<script src="js/algorithms/selectionSort.js"></script>
<script src="js/scripts.min.js"></script>
</body>
</html>
