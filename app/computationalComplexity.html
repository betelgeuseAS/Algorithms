<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <!-- <base href="/"> -->

  <title>Вычислительная сложность</title>
  <meta name="description" content="">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- Template Basic Images Start -->
  <meta property="og:image" content="path/to/image.jpg">
  <link rel="icon" href="img/favicon/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="img/favicon/apple-touch-icon-180x180.png">
  <!-- Template Basic Images End -->

  <!-- Custom Browsers Color Start -->
  <meta name="theme-color" content="#000">
  <!-- Custom Browsers Color End -->

  <link rel="stylesheet" href="css/main.min.css">
</head>
<body>

<header>
  <div class="container">
    <div class="row">
      <div class="col-8">
        <div class="name">
          <h1><a href="index.html"><i class="fa fa-sun-o" aria-hidden="true"></i> Algorithms</a></h1>
        </div>
      </div>
      <div class="col-4">
        <ul>
          <li><a target="_blank" href="https://github.com/betelgeuseAS/Algorithms">GitHub <i class="fa fa-link" aria-hidden="true"></i></a></li>
        </ul>
      </div>
    </div>
  </div>
</header>


<section>
  <div class="container">
    <div class="row">
      <div class="col-md-9 col-sm-12">
        <div class="leftSide">
          <h1>Вычислительная сложность</h1>
          <p>Каждый раз, когда мы будем рассматривать очередной алгоритм, я буду обсуждать время его выполнения. Обычно следует выбирать самый эффективный алгоритм, будь то оптимизация по времени или памяти.</p>
          <p>Вернемся к бинарному поиску. Сколько времени сэкономит его применение? В первом варианте мы последовательно проверяли каждое число, одно за другим. Если список состоит из 100 чисел, может потребоваться до 100 попыток. Для списка из 4 миллиардов чисел потребуется до 4 миллиардов попыток. Таким образом, максимальное количество попыток совпадает с размером списка. Такое время выполнения называется <em>линейным</em>.</p>
          <p>С бинарным поиском дело обстоит иначе. Если список состоит из 100 элементов, потребуется не более 7 попыток. Для списка из 4 миллиардов элементов потребуется не более 32 попыток. Бинарный поиск выполняется за <em>логарифмическое</em> время. В следующей таблице приводится краткая сводка результатов.</p>

          <img src="img/algorithms/Computational%20complexity/cc01.jpg" class="img-responsive" alt="Computational complexity">

          <strong class="alignCenter">Время выполнения алгоритмов поиска</strong>

          <hr>

          <h3>«О-большое»</h3>
          <p>Специальная нотация "0-болъшое" описывает скорость работы алгоритма. Зачем вам это? Время от времени вам придется использовать чужие алгоритмы, а потому неплохо было бы понимать, насколько быстро или медленно они работают.</p>

          <hr>

          <h3>Время выполнения алгоритмов растет с разной скоростью</h3>
          <p>Боб пишет алгоритм поиска для NASA. Его алгоритм заработает, когда ракета будет подлетать к Луне, и поможет вычислить точку посадки.</p>
          <p>Это один из примеров того, как время выполнения двух алгоритмов растет с разной скоростью. Боб пытается выбрать между простым и бинарным поиском. Его алгоритм должен работать быстро и правильно. С одной стороны, бинарный поиск работает быстрее. У Боба есть всего 10 секунд, чтобы выбрать место посадки; если он не уложится в это время, то момент для посадки будет упущен. С другой стороны, простой поиск пишется проще и вероятность ошибок в нем ниже... Конечно, Боб совершенно не хочет допустить ошибку в коде посадки ракеты. И тогда для пущей уверенности Боб решает измерить время выполнения обоих алгоритмов для списка из 100 элементов.</p>
          <p>Допустим, проверка одного элемента занимает 1 миллисекунду (мс). При простом поиске Бобу придется проверить 100 элементов, поэтому поиск займет 100 мс. С другой стороны, при бинарном поиске достаточно проверить всего 7 элементов (log<sub>2</sub>100 равен приблизительно 7), а поиск займет 7 мс. Но реальный список может содержать более миллиарда элементов. Сколько времени в таком случае потребуется для выполнения простого поиска? А при бинарном поиске?</p>

          <img src="img/algorithms/Computational%20complexity/cc02.jpg" class="img-responsive" alt="Computational complexity">

          <strong class="alignCenter">Время выполнения простого и бинарного поиска для списка из 100 элементов</strong>

          <p>Боб проводит бинарный поиск с 1 миллиардом элементов, и на это уходит 30 мс (log<sub>2</sub>1 ООО ООО ООО равен приблизительно 30). «32 мс! - думает Боб. Бинарный поиск в 15 раз быстрее простого, потому что простой поиск для 100 элементов занял 100 мс, а бинарный поиск занял 7 мс. Значит, простой поиск займет 30 х 15 = 450 мс, верно? Гораздо меньше отведенных 10 секунд~. И Боб выбирает простой поиск. Верен ли его выбор?</p>
          <p>Нет, Боб ошибается. Глубоко ошибается. Время выполнения для простого поиска с 1 миллиардом элементов составит 1 миллиард миллисекунд, а это 11 дней! Проблема в том, что время выполнения для бинарного и простого поиска <em>растет с разной скоростью</em>.</p>

          <img src="img/algorithms/Computational%20complexity/cc03.jpg" class="img-responsive" alt="Computational complexity">

          <strong class="alignCenter">Время выполнения растет с совершенно разной скоростью!</strong>

          <p>Другими словами, с увеличением количества элементов бинарный поиск занимает чуть больше времени. А простой поиск займет гораздо больше времени. Таким образом, с увеличением списка бинарный список внезапно начинает работать гораздо быстрее простого. Боб думал, что бинарный поиск работает в 15 раз быстрее простого, но это не так. Если список состоит из 1 миллиарда элементов, бинарный поиск работает приблизительно в 33 миллиона раз быстрее. Бот почему недостаточно знать, сколько времени должен работать алгоритм, - необходимо знать, как возрастает время выполнения с ростом размера списка. Здесь-то вам и пригодится "О-большое".</p>
          <p>«О-большое» описывает, насколько быстро работает алгоритм. Предположим, имеется список размера n. Простой поиск должен проверить каждый элемент, поэтому ему придется выполнить n операций. Бремя выполнения «О-большое» имеет вид О(n). Постойте, но где же секунды? А их здесь нет - «О-большое» не сообщает скорость в секундах, а позволяет сравнить количество операций. Оно указывает, насколько быстро возрастает время выполнения алгоритма</p>
          <p>А теперь другой пример. Для проверки списка размером n бинарному поиску потребуется log n операций. Как будет выглядеть «О-большое»? O(log n). В общем случае «О-большое» выглядит так:</p>

          <img src="img/algorithms/Computational%20complexity/cc04.jpg" class="img-responsive" alt="Computational complexity">

          <strong class="alignCenter">Как записывается «О-большое»</strong>

          <p>Такая запись сообщает количество операций, которые придется выполнить алгоритму. Она называется «О-большое», потому что перед количеством операций ставится символ «0» (а большое - потому что в верхнем регистре).</p>

          <hr>

          <h3>«О-большое» определяет время выполнения в худшем случае</h3>
          <p>Предположим, вы используете простой поиск для поиска фамилии в телефонной книге. Вы знаете, что простой поиск выполняется за время О(n), то есть в худшем случае вам придется просмотреть каждую без исключения запись в телефонной книге. Но представьте, что искомая фамилия начинается на букву «А» и этот человек стоит на самом первом месте в вашей телефонной книге. В общем, вам не пришлось просматривать все записи вы нашли нужную фамилию с первой попытки. Отработал ли алгоритм за время О(n)? А может, он занял время 0(1), потому что результат был получен с первой попытки?</p>
          <p>Простой поиск все равно выполняется за время О(n). Просто в данном случае вы нашли нужное значение моментально; это лучший возможный случай. Однако «О-большое» описывает худший возможный случай. Фактически вы утверждаете, что в худшем случае придется просмотреть каждую запись в телефонной книге по одному разу. Это и есть время О(n). И это дает определенные гарантии - вы знаете, что простой поиск никогда не будет работать медленнее О(n).</p>

          <div class="tip tipDanger">
            <h4>ПРИМЕЧАНИЕ</h4>
            <p>Наряду с временем худшего случая также полезно учитывать среднее время выполнения.</p>
          </div>

          <hr>

          <h3>Типичные примеры «О-большого»</h3>
          <p>Ниже перечислены разновидности «О-большого», которые будут встречаться вам особенно часто, в порядке убывания скорости выполнения:</p>
          <ul>
            <li><em>О(1)</em>, или <em>константное время</em>. Пример: поиск в хэш-таблице.</li>
            <li><em>О(log n)</em>, или <em>логарифмическое время</em>. Пример: бинарный поиск.</li>
            <li><em>О(n)</em>, или <em>линейное время</em>. Пример: простой поиск или поиск наибольшего элемента.</li>
            <li><em>О(n * log n)</em>, или <em>квазилинейное время</em>. Пример: эффективные алгоритмы сортировки (быстрая сортировка).</li>
            <li><em>О(n<sup>m</sup>)</em>, или <em>полиномиальное время</em>. Пример: медленные алгоритмы сортировки (<em>О(n<sup>2</sup>)</em> сортировка вставками или сортировка пузырьком).</li>
            <li><em>О(m<sup>n</sup>)</em>, или <em>экспоненциальное время</em>.</li>
            <li><em>О(n!)</em>, или <em>факториальное время</em>. Пример: очень медленные алгоритмы (задача о коммивояжере)</li>
          </ul>
          <p>m - константа, n - количество входных данных.</p>
          <p>Существуют и другие варианты времени выполнения, но эти встречаются чаще всего.</p>
          <p>Будет полезно посмотреть на график «О-большое»:</p>

          <img src="img/algorithms/Computational%20complexity/cc05.png" class="img-responsive" alt="Computational complexity">

          <strong class="alignCenter">График роста O — большое</strong>

          <p>Помните, что эта запись является упрощением. На практике «О-большое» не удается легко преобразовать в количество операций с такой точностью. А пока перечислим основные результаты:</p>
          <ul>
            <li>Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций.</li>
            <li>По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.</li>
            <li>Время выполнения алгоритмов выражается как «О-большое».</li>
          </ul>

          <hr>

          <h3>Задача о коммивояжере</h3>
          <p>Мы рассмотрим алгоритм с очень, очень плохим временем выполнения (О(n!)). Это известная задача из области теории вычислений, в которой время выполнения растет с просто ужасающей скоростью, и некоторые очень умные люди считают, что с этим ничего не поделать. Она называется задачей о коммивояжере.</p>

          <img src="img/algorithms/Computational%20complexity/cc06.jpg" class="img-responsive" alt="Computational complexity">

          <p>Это коммивояжер.</p>
          <p>Он должен объехать 5 городов.</p>

          <img src="img/algorithms/Computational%20complexity/cc07.jpg" class="img-responsive" alt="Computational complexity">

          <p>Коммивояжер хочет побывать в каждом из 5 городов так, чтобы при этом проехать минимальное общее расстояние. Одно из возможных решений: нужно перебрать все возможные комбинации порядка объезда городов.</p>

          <img src="img/algorithms/Computational%20complexity/cc08.jpg" class="img-responsive" alt="Computational complexity">

          <p>Все расстояния суммируются, после чего выбирается путь с кратчайшим расстоянием. Для 5 городов можно создать 120 перестановок, поэтому решение задачи для 5 городов потребует 120 операций. Для 6 городов количество операций увеличивается до 720 (существуют 720 возможных перестановок). А для 7 городов потребуется уже 5040 операций!</p>

          <img src="img/algorithms/Computational%20complexity/cc09.jpg" class="img-responsive" alt="Computational complexity">

          <p>В общем случае для вычисления результата при n элементах потребуется n! (n-факториал) операций. А значит, время выполнения составит О(n!) (такое время называется факториальным). При любом сколько-нибудь серьезном размере списка количество операций будет просто огромным. Скажем, если вы попытаетесь решить задачу для 100+ городов, сделать это вовремя не удастся - Солнце погаснет раньше.</p>
          <p>Какой ужасный алгоритм! Значит, коммивояжер должен найти другое решение, верно? Но у него ничего не получится. Это одна из знаменитых нерешенных задач в области теории вычислений. Для нее не существует известного быстрого алгоритма, и ученые считают, что найти более эффективный алгоритм для этой задачи в принципе невозможно. В лучшем случае для нее можно поискать приближенное решение.</p>











        </div>
      </div>

      <div class="col-md-3 col-sm-12">
        <div class="rightSide">
          <ul>
            <li><a href="binarySearch.html">Бинарный поиск</a></li>
          </ul>

          <ul>
            <li class="active"><a href="computationalComplexity.html">Вычислительная сложность</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</section>


<footer>
  <div class="container">
    <div class="row">
      <div class="col-12">
        <p>На основе книги <a class="link" target="_blank" href="https://www.manning.com/books/grokking-algorithms">Grokking Algorithms</a> - Aditya Y. Bhargava</p>
      </div>
    </div>
  </div>
</footer>


<!--Hamburger menu:-->
<div class="hamburger">
  <div class="buttonContainer">
    <span class="top"></span>
    <span class="middle"></span>
    <span class="bottom"></span>
  </div>
</div>


<script src="js/scripts.min.js"></script>
</body>
</html>
